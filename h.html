<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Camera Control</title>
</head>

<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        let divisions = 15;

        let gridX = new THREE.GridHelper(25, divisions);
        scene.add(gridX);

        const light = new THREE.AmbientLight(0xe0b284);
        scene.add(light);

        let radius = 10;
        let mouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let angleX = 0;
        let angleY = 0;

        renderer.domElement.addEventListener('mousedown', (event) => {
            mouseDown = true;
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        }, false);

        renderer.domElement.addEventListener('mouseup', () => {
            mouseDown = false;
        }, false);

        renderer.domElement.addEventListener('mousemove', (event) => {
            if (mouseDown) {
                let x = (event.clientX / window.innerWidth) * 2 - 1;
                let y = -(event.clientY / window.innerHeight) * 2 + 1;

                let deltaX = x - mouseX;
                let deltaY = y - mouseY;

                const rotationSpeed = 2;
                angleX += deltaX * rotationSpeed;
                angleY += deltaY * rotationSpeed;
                angleY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, angleY));

                const cameraX = -radius * Math.cos(angleY) * Math.sin(angleX);
                const cameraY = -radius * Math.sin(angleY);
                const cameraZ = radius * Math.cos(angleY) * Math.cos(angleX);

                camera.position.set(cameraX, cameraY, cameraZ);
                camera.lookAt(0,0,0);

                mouseX = x;
                mouseY = y;
            }
        }, false);

        renderer.domElement.addEventListener('contextmenu', (event) => {
            event.preventDefault();
        }, false);

        renderer.domElement.addEventListener('wheel', (event) => {
            if (event.deltaY > 0){
                radius += 2;
            }
            else{
                radius -= 2;
            }

            radius = Math.max(5, Math.min(50, radius));

            const cameraX = -radius * Math.cos(angleY) * Math.sin(angleX);
            const cameraY = -radius * Math.sin(angleY);
            const cameraZ = radius * Math.cos(angleY) * Math.cos(angleX);
            camera.position.set(cameraX, cameraY, cameraZ);

            event.preventDefault();
        }, false);

        window.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowUp') {
                divisions = Math.min(divisions + 5, 50);
            }
            if (event.key === 'ArrowDown') {
                divisions = Math.max(divisions - 5, 5);
            }
            scene.remove(gridX);
            gridX = new THREE.GridHelper(25, divisions);
            scene.add(gridX);
            event.preventDefault();
        });

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
